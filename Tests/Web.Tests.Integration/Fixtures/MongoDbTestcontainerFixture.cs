using MongoDB.Driver;

using Shared;
using Shared.Entities;

using Testcontainers.MongoDb;

namespace Web.Fixtures;

/// <summary>
/// Test fixture that uses Testcontainers.MongoDb (via the Testcontainers.MongoDb package)
/// to create a disposable MongoDB container for integration tests.
/// </summary>
public sealed class MongoDbTestcontainerFixture : IAsyncLifetime
{
	private MongoDbContainer? _container;

	public string ConnectionString { get; private set; } = string.Empty;

	public MongoClient Client { get; private set; } = null!;

	public MongoDbTestcontainerFixture()
	{
	}

	public async ValueTask InitializeAsync()
	{
		// Build and start a MongoDB testcontainer
		_container = new MongoDbBuilder()
			.WithImage("mongo:6.0")
			.Build();

		await _container.StartAsync();

		// Testcontainers.MongoDb exposes a GetConnectionString() method
		ConnectionString = _container.GetConnectionString();

		Client = new MongoClient(ConnectionString);

		// wait for availability
		var maxAttempts = 20;
		for (var i = 0; i < maxAttempts; i++)
		{
			try
			{
				await Client.ListDatabaseNamesAsync(CancellationToken.None);
				break;
			}
			catch
			{
				await Task.Delay(250, CancellationToken.None);
			}
		}
	}

	public async ValueTask DisposeAsync()
	{
		if (_container != null)
		{
			await _container.StopAsync();
			await _container.DisposeAsync();
		}

		Client = null!;
	}

	/// <summary>
	/// Seeds the Articles collection with fake articles generated by Shared.Fakes.
	/// This will drop the existing collection first to ensure a clean state.
	/// </summary>
	public async Task SeedArticlesAsync(int count = 5, bool useSeed = false)
	{
		var db = Client.GetDatabase(Services.DATABASE);
		// Ensure a clean collection for deterministic tests
		try { await db.DropCollectionAsync("Articles", CancellationToken.None); } catch { }

		var articles = Shared.Fakes.FakeArticle.GetArticles(count, useSeed);
		var col = db.GetCollection<Article>("Articles");
		if (articles?.Any() == true)
		{
			await col.InsertManyAsync(articles, null, CancellationToken.None);
		}
	}

}
