# This workflow will build a .NET project
# CI: ensure TRX/log collection and artifact upload (copilot branch)
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net
name: Build and Test .NET projects

on:
  push:
    paths-ignore:
      - "**/*.docs"
      - "**/*.md"
      - "**/*.gitignore"
      - "**/*.gitattributes"

  workflow_dispatch:
    inputs:
      reason:
        description: "The reason for running the workflow"
        required: true
        default: "Manual run"

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  build:
    runs-on: ubuntu-latest

    # Allow the job to request OIDC tokens for Codecov tokenless uploads
    permissions:
      id-token: write

    env:
      NUGET_PACKAGES: ${{ github.workspace }}/.nuget/packages

    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"
          cache-dependency-path: SRC/Web/package-lock.json

      - name: Install Node.js dependencies
        working-directory: SRC/Web
        run: npm install

      - name: Build Tailwind CSS
        working-directory: SRC/Web
        run: npm run build:css

      - name: Restore dependencies
        run: dotnet restore BlazorBlogApplication.sln

      - name: Build
        run: dotnet build BlazorBlogApplication.sln --no-restore

      - name: Run all tests in all test projects
        id: run-tests
        run: |
          # Ensure repository-level TestResults exists
          mkdir -p "TestResults"
          timestamp=$(date +%s)

          set -o pipefail


          while IFS= read -r proj; do
            if grep -q "<IsTestProject>true</IsTestProject>" "$proj" 2>/dev/null; then
              name=$(basename "$proj" .csproj)
              filename="${name}_${timestamp}"
              echo "Running tests for: $proj -> TestResults/${filename}.trx (logs -> TestResults/${filename}.coverage.log)"

              set +e
              dotnet test "$proj" \
                --no-build --no-restore \
                --logger "trx;LogFileName=${filename}.trx" \
                --logger "junit;LogFileName=${filename}.coverage.xml" \
                --collect:"XPlat Code Coverage" \
                --settings runsettings.xml \
                --results-directory "TestResults" 2>&1 | tee "TestResults/${filename}.log"

              rc=$?
              set -e

              if [ "$rc" -ne 0 ]; then
                echo "dotnet test failed for $proj (exit code $rc)"
                overall_rc=$rc
              fi
            else
              echo "Skipping non-test project: $proj"
            fi
          done < <( find Tests -name "*.csproj" -type f 2>/dev/null || true )

          echo "tests_exit_code=$overall_rc" >> "$GITHUB_OUTPUT"
          exit 0

      - name: Workspace And TestResults Folder
        id: check-test-results
        run: |
          echo "=== TestResults Diagnostic Information ==="
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          echo "Listing repo root:"
          ls -la "$GITHUB_WORKSPACE" || true
          echo ""
          echo "=== Checking TestResults Folder ==="
          echo "Looking for TestResults folder at: TestResults"
          found_trx=false
          if [ -d "TestResults" ]; then
            echo "✅ TestResults folder found"
            echo ""
            echo "=== TestResults Directory Contents (top-level) ==="
            ls -la "TestResults" || true
            echo ""
            echo "=== Recursive Search for .trx Files ==="
            # Use find safely and handle zero results
            mapfile -t trx_files < <(find "TestResults" -type f -name "*.trx" 2>/dev/null || true)
            trx_count=${#trx_files[@]}
            echo "Search command: find \"TestResults\" -type f -name \"*.trx\""
            echo "Files found: $trx_count"

            if [ "$trx_count" -gt 0 ]; then
              echo "✅ Found $trx_count .trx file(s) in TestResults (recursive search)"
              echo "=== List of .trx Files Found ==="
              for f in "${trx_files[@]}"; do
                echo "$f"
                ls -la "$f" || true
                echo "--- Contents preview (first 50 lines) ---"
                head -n 50 "$f" || true
                echo "--- End preview ---"
              done
              found_trx=true
            else
              echo "❌ No .trx files found in TestResults directory"
            fi
          else
            echo "❌ TestResults folder NOT found"
          fi

            # Also detect per-project logs
            mapfile -t log_files < <(find "TestResults" -type f -name "*.log" 2>/dev/null || true)
            log_count=${#log_files[@]}
            echo "Log files found: $log_count"
            if [ "$log_count" -gt 0 ]; then
              echo "=== List of .log Files Found ==="
              for lf in "${log_files[@]}"; do
                echo "$lf"
                ls -la "$lf" || true
              done
            fi

            # Export the result as a step output
            echo "found_trx=$found_trx" >> "$GITHUB_OUTPUT"
            echo "found_logs=$([ $log_count -gt 0 ] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo ""
          echo "=== Summary ==="
          echo "TestResults folder exists: $([ -d \"TestResults\" ] && echo 'true' || echo 'false')"
          echo "TRX files found: $found_trx"
            echo "Log files found: $([ $log_count -gt 0 ] && echo 'true' || echo 'false')"

      - name: Upload Test Results
        if: ${{ steps.check-test-results.outputs.found_trx == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: Test-Results
          path: TestResults/**/*.trx

      - name: Upload TestResults (fallback for debugging)
        if: ${{ steps.check-test-results.outputs.found_trx != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: TestResults-Debug
          path: TestResults/**

      - name: Upload Test Logs
        if: ${{ steps.check-test-results.outputs.found_logs == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: Test-Logs
          path: ${{ github.workspace }}/TestResults/**/*.log

      - name: Upload coverage to Codecov (explicit)
        uses: codecov/codecov-action@v5
        with:
          # Search the TestResults folder where dotnet test writes coverage XML
          directory: TestResults
          # Explicitly look for common coverage file names created by coverlet / XPlat collector
          files: TestResults/**/*.xml,TestResults/**/coverage.cobertura.xml,TestResults/**/*.coverage.xml,**/coverage.cobertura.xml
          # Don't fail the whole CI when Codecov has a problem; set as desired
          fail_ci_if_error: false
          # Helpful when debugging why files aren't found
          verbose: true
          # Optional: group this upload under a flag
          flags: unittests
        # Use OIDC to authenticate uploads where possible (public repos or org-level allowlist)
      # Use OIDC or CODECOV_TOKEN (set as a repo secret) for authentication. No explicit env required here.

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/test-results-action@v1

      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2
        id: test-results
        # When running locally with the 'nektos/act,' the GITHUB_ACTOR is 'nektos/act' and
        # the runner can't access GitHub's API for local commit SHAs. Skip
        # publishing test results (which queries commits/pull requests) in
        # that case to avoid 403/422 API errors.
        if: always() && github.actor != 'nektos/act'
        with:
          # Disable creating GitHub check runs when running locally with 'nektos/act'
          # (this avoids the "You must authenticate via a GitHub App" 403 error
          # that happens because 'nektos/act' can't emulate GitHub App authentication).
          check_run: false
          files: |
            ${{ github.workspace }}/TestResults/**/*.trx
            ${{ github.workspace }}/TestResults/**/*.xml
            ${{ github.workspace }}/TestResults/**/*.xml

      - name: Install GitVersion
        if: github.actor != 'nektos/act'
        uses: gittools/actions/gitversion/setup@v4.1.0
        with:
          versionSpec: "6.3.x"

      - name: Use GitVersion
        if: github.actor != 'nektos/act'
        id: gitversion # step id used as a reference for output values
        uses: gittools/actions/gitversion/execute@v4.1.0

      - name: Show GitVersion
        if: github.actor != 'nektos/act'
        run: |
          echo "FullSemVer: ${{ steps.gitversion.outputs.fullSemVer }}"
          echo "MajorMinorPatch: ${{ steps.gitversion.outputs.majorMinorPatch }}"

      - name: Fail on test failures
        if: always()
        run: |
          # If the run-tests step exported a non-zero exit code, fail now
          tests_exit_code=${{ steps.run-tests.outputs.tests_exit_code }}
          echo "tests_exit_code=$tests_exit_code"
          if [ "$tests_exit_code" != "0" ]; then
            echo "Tests failed with exit code $tests_exit_code"
            exit $tests_exit_code
          fi
